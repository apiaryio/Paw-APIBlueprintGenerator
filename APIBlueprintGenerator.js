// Generated by CoffeeScript 1.9.3
(function() {
  var APIBlueprintGenerator;

  require("mustache.js");

  APIBlueprintGenerator = function() {
    this.response = function(exchange) {
      var body, body_indentation, has_body, has_headers, headers, is_json, key, ref, value;
      if (!exchange) {
        return null;
      }
      headers = [];
      is_json = false;
      ref = exchange.responseHeaders;
      for (key in ref) {
        value = ref[key];
        if (key === 'Content-Type' || key === 'Connection' || key === 'Date' || key === 'Via' || key === 'Server' || key === 'Content-Length') {
          is_json = key === 'Content-Type' && value.search(/(json)/i) > -1;
          continue;
        }
        headers.push({
          key: key,
          value: value
        });
      }
      has_headers = headers.length > 0;
      body = exchange.responseBody;
      has_body = body.length > 0;
      if (has_body) {
        if (is_json) {
          body = JSON.stringify(JSON.parse(body), null, 4);
        }
        body_indentation = '        ';
        if (has_headers) {
          body_indentation += '    ';
        }
        body = body.replace(/^/gm, body_indentation);
      }
      return {
        statusCode: exchange.responseStatusCode,
        contentType: exchange.responseHeaders['Content-Type'],
        "headers?": has_headers,
        headers: headers,
        "body?": has_headers && has_body,
        body: body
      };
    };
    this.request = function(paw_request) {
      var body, body_indentation, has_body, has_headers, headers, is_json, key, ref, value;
      headers = [];
      is_json = false;
      ref = paw_request.headers;
      for (key in ref) {
        value = ref[key];
        if (key === 'Content-Type') {
          is_json = value.search(/(json)/i) > -1;
          continue;
        }
        headers.push({
          key: key,
          value: value
        });
      }
      has_headers = headers.length > 0;
      body = paw_request.body;
      has_body = body.length > 0;
      if (has_body) {
        if (is_json) {
          body = JSON.stringify(JSON.parse(body), null, 4);
        }
        body_indentation = '        ';
        if (has_headers) {
          body_indentation += '    ';
        }
        body = body.replace(/^/gm, body_indentation);
      }
      if (has_headers || has_body || paw_request.headers['Content-Type']) {
        return {
          "headers?": has_headers,
          headers: headers,
          contentType: paw_request.headers['Content-Type'],
          "body?": has_headers && has_body,
          body: body
        };
      }
    };
    this.path = function(url) {
      var path;
      path = url.replace(/^https?:\/\/[^\/]+/i, '');
      if (!path) {
        path = '/';
      }
      return path;
    };
    this.generate = function(context) {
      var paw_request, template, url;
      paw_request = context.getCurrentRequest();
      url = paw_request.url;
      template = readFile("apiblueprint.mustache");
      return Mustache.render(template, {
        method: paw_request.method,
        path: this.path(url),
        request: this.request(paw_request),
        response: this.response(paw_request.getLastExchange())
      });
    };
  };

  APIBlueprintGenerator.identifier = "io.apiary.PawExtensions.APIBlueprintGenerator";

  APIBlueprintGenerator.title = "API Blueprint Generator";

  APIBlueprintGenerator.fileExtension = "md";

  registerCodeGenerator(APIBlueprintGenerator);

}).call(this);
